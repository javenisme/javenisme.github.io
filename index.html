
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Javen's Blog</title>
  <meta name="author" content="Javen">

  
  <meta name="description" content="
">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://javenisme.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Javen's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

<!-- <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-63174184-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Javen's Blog</a></h1>
  
    <h2>匠心雕龙.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="javenisme.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/26/mvvm-shi-zhan/">MVVM 实战</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-26T14:38:43+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:38 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/25/swift-tips-1/">Swift Tips (1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-25T01:17:14+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:17 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>类和结构体的共同点</h3>

<p>Swift 中类和结构体有很多共同点。共同处在于：
定义属性用于存储值
定义方法用于提供功能
定义附属脚本用于访问值
定义构造器用于生成初始化值
通过扩展以增加默认实现的功能
符合协议以对某类提供标准功能</p>

<p>还有如下的附加功能：
继承允许一个类继承另一个类的特征
类型转换允许在运行时检查和解释一个类实例的类型
解构器允许一个类实例释放任何其所被分配的资源
引用计数允许对一个类的多次引用</p>

<h3>结构体和类的选择</h3>

<p>结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据构造和功能的时候，你需要决定每个数据构造是定义成类还是结构体。
按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体：
结构体的主要目的是用来封装少量相关简单数据值。
有理由预计一个结构体实例在赋值或传递时，封装的数据将会被拷贝而不是被引用。
任何在结构体中储存的值类型属性，也将会被拷贝，而不是被引用。
结构体不需要去继承另一个已存在类型的属性或者行为。</p>

<p>合适的结构体候选者包括:
几何形状的大小，封装一个width属性和height属性，两者均为Double类型。
一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。
三维坐标系内一点，封装x，y和z属性，三者均为Double类型。
在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自
定义数据构造都应该是类，而非结构体。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/19/chuangye/">创业4个月总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-07-19T14:38:43+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>2:38 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>加入康源的4个月总结</p>

<p>14年3月17号，我做出一个不那么艰难的决定，加入康源，一家在新兴领域用新方法解决健康管理的初创公司。一晃4个月过去了，记得满个3月的时候恰巧赶上余总下班后还没走，就兴起找他聊了会，主要是3个月总结和未来的规划：</p>

<p>在康源是接受信息量最大，挑战最为艰巨的，一方面来自产品需求的精益求精的苛刻，另一方面是自身实现卓越的压迫。和各位老师学到的做事方法论，批判式思维的分析问题，让我能在站在一个更全面的角度思考新问题，学会断言的科学评判方法，这是给我最大的收获。</p>

<p>同时，针对公司的各方面我也有自己的见解，对于运营，产品，招聘的一些环节，有时我并不会坚持自己认为对的观点，比较容易妥协。但事后可能需要时间说服自己去接受当时没说出来的观点，这都是我非常明显的缺陷，要向子超总学习 :-)</p>

<p>加入初创公司该有怎样的心态的问题，上一篇文章写过，承蒙项老师推荐还被创业家网站转载了 XD。</p>

<p>经常有面试到最后的工程师问我们：如果腾讯，百度进来这个市场你们怎么办？</p>

<p>这个问题我想如果是深入理解互联网，并有所总结和思考的从业者都会有自己的答案。互联网是一种方法论，是思维方式，在社会化变革洪流中互联网起到一个怎样的</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/14/startup-zhao-pin/">初创公司如何招聘</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-05-14T14:38:43+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>2:38 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>前言
我是一家初创公司的开发人员。</p>

<p>我公司立志用智能穿戴硬件，移动和大数据技术解决人们健康可视化的难题。在我加入之时刚有7个人，技术上CTO和我做软件方面。由于我们是一家软硬件结合的公司，涉及大量的工作，当时处于百业待兴的状态，面临的第一个问题就是人员招聘，从哪里开始做，如何做，都是摆在团队面前的亟待解决的难题。</p>

<p>为什么写这篇文章？
参与创业，从0开始做一件产品是一个充满期待和挑战的过程。每个人面临的问题都是之前没遇到过的。很多错误只有在犯过之后，总结出体会才会对后来的人有价值。如果能帮助后来的朋友在创业之初少走些弯路，节省些磨合时间，善莫大焉。</p>

<p>从哪下手招人？
人一天精力有限，在创业团队更是如此。我认为该把时间用来解决公司最紧迫的问题上。既然我加入了这里，何不在我的圈子里招合适的人一起做事？有这想法和CEO，CTO们一商量，上手就很快了。V2EX，CocoaChina，拉沟社区，小道消息，水木都成了我的渠道，甚至还有线下的车库咖啡。</p>

<p>反馈者寥寥！为什么？因为我们还没有自己的网站。和有意向的朋友聊天，问的最多的问题是，做什么，怎么做，和哪些人做，有网站吗？说实话，做什么我知道，怎么做不知道，初创期每天都在风暴，每天都在变动，域名，商标和产品名称变了3次（这个以后再展开）如果没有一个网站上线，每个都需要从0开始沟通一遍，不是不可以而是效率低下到渣。</p>

<p>认识到这个问题，我们分几次开会确定专用人员招聘的网站如何做，一周后原始版本上线了。
是的，没有备案，还有很多Bug，在移动端适配上有很多问题，第一版本放在SAE，用日本的DNS解析，绕过了备案。如果等到备案完成，恐怕1，2个月都过去了，那简直让人无法忍受。就这样不完全按套路出牌，在没有专职HR情况下人员招聘跌跌撞撞展开了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/05/01/healthkit-learning/">HealthKit深度剖析</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-05-01T14:38:43+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>2:38 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>HealthKit 深度剖析</p>

<p>HealthKit允许app提供健康和健身服务以新的健康应用分享数据。用户的健康信息存储在中心化并且安全的本地。并且用户决定哪些数据应该被分享给你的APP。</p>

<p>HealthKit 是一个新的提供给用户管理自身健康相关信息的框架。由于</p>

<p>本次更新iOS8释放出的HealthKit针对APP developers：
提供了HealthKit Framework</p>

<p>HealthKit还将提供一个供其他应用相互共享信息的中央系统，这样耐克(Nike)的跑步应用就能自动从互联网端的WiThings电子秤上收集体重数据了。
苹果希望这一新的平台，能使其成为应用开发者、保健供应商以及可穿戴设备生产商的中心，目前这些与健康相关的产品社区正在不断增长，而很多公司竞相对用户的健康数据提出单方面意见。</p>

<p>五、Healthkit+Homekit，苹果式的连通万物
这两套API无疑是今天的重头。
Healthkit为可穿戴设备和App提供了数据接口，而自带应用Health则取代传闻中的Healthbook，成为苹果为健康类硬件和App搭建的信息窗口、控制中心、以及数据池。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/25/helloworld/">HelloWorld</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-04-25T10:27:09+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>10:27 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/02/Delegate-Notification-KVO-learning/">NSNotification、delegate和KVO的深度对比</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-03-02T00:38:43+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2014</span></span> <span class='time'>12:38 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1.效率肯定是delegate比nsnotification高。</p>

<p>2.delegate方法比notification更加直接，最典型的特征是，delegate方法往往需要关注返回值，也就是delegate方法的结果。比如-windowShouldClose:，需要关心返回的是yes还是no。所以delegate方法往往包含should这个很传神的词。也就是好比你做我的delegate，我会问你我想关闭窗口你愿意吗？你需要给我一个答案，我根据你的答案来决定如何做下一步。相反的，notification最大的特色就是不关心接受者的态度，我只管把通告放出来，你接受不接受就是你的事情，同时我也不关心结果。所以notification往往用did这个词汇，比如NSWindowDidResizeNotification，那么nswindow对象放出这个notification后就什么都不管了也不会等待接受者的反应。</p>

<p>简明概要的说明了KVO和NSNotification的区别：</p>

<p>和delegate一样，KVO和NSNotification的作用也是类与类之间的通信，与delegate不同的是1）这两个都是负责发出通知，剩下的事情就不管了，所以没有返回值；2）delegate只是一对一，而这两个可以一对多。这两者也有各自的特点。</p>

<p>1）KVO的使用：
被观察者发出 addObserver:forKeyPath:options:context: 方法来添加观察者。</p>

<p>然后只要被观察者的keyPath值变化(注意：单纯改变其值不会调用此方法，只有通过getters和setters来改变值才会触发KVO)，就会在观察者里调用方法observeValueForKeyPath:ofObject:change:context:
因此观察者需要实现方法 observeValueForKeyPath:ofObject:change:context: 来对KVO发出的通知做出响应。</p>

<p>这些代码都只需在观察者里进行实现，被观察者不用添加任何代码，所以谁要监听谁注册，然后对响应进行处理即可，使得观察者与被观察者完全解耦，运用很灵活很简便；但是KVO只能检测类中的属性，并且属性名都是通过NSString来查找，编译器不会帮你检错和补全，纯手敲所以比较容易出错。</p>

<p>2）NSNotification的使用
这里的通知不是由被观察者发出，而是由NSNotificationCenter来统一发出，而不同通知通过唯一的通知标识名notificationName来区分</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/06/26/mvvm-shi-zhan/">MVVM 实战</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/25/swift-tips-1/">Swift Tips (1)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/19/chuangye/">创业4个月总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/14/startup-zhao-pin/">初创公司如何招聘</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/01/healthkit-learning/">HealthKit深度剖析</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Javen -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
